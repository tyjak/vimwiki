= Tips Git & Github =

== Authentification ==

	* fichier ~/.git-credentials TODO:command pour générer ce ficher
	* command `git config credential.helper 'store'` pour utiliser l'authentification permanente
	* préférer l'authentification par clefs ssh (git@github.com)

== Tutorial ==

 Excellent [[http://blog.octo.com/git-dans-la-pratique-12/|tuto]] Git 
 Plein de [[https://orga.cat/posts/most-useful-git-commands|commandes utiles]]
 
== Github ==

Créer un projet sur github et le tracker en local

{{{
    $ git init
    $ git remote add origin git@github.com:username/new_repo
    $ git push -u origin master
}}}

== Quelques commandes utiles ==

    * `git branch` pour lister les branches
    * `git branch -r` pour lister les branches trackées du remote
    * `git checkout -b {nom de la branche}` pour créer une nouvelle branche
    * `git commit --amend` pour modifier le dernier commit
    * `git commit --amend --no-edit` pour ajouter un/des fichiers oubliés au dernier commit
    * `git reset <file>` pour annuler l'ajout d'un fichier (seulement en local)
    * `git reset --hard <file>` pour annuler l'ajout d'un fichier et revenir au dernier état (HEAD)
    * `git reset HEAD~` annule un commit sans modification des fichiers
    * `git reset --merge ORIG_HEAD` annule le dernier merge dans modifier les fichiers locaux modifés (dans le cas d'un merge non pushé)
    * `git checkout -- filename` annule les modifications d'un fichier local
    * `git log --graph --oneline --all` graph des commit
    * `git branch master -u {repo_distant}/master` pour indiquer le repo distant de la branche
    * `git fetch upstream && git checkout master && git merge upstream/master` pour [[https://www.sumonselim.com/sync-forked-github-repository-master/|synchroniser un fork]] avec le projet d'origine 
    * `git push -u origin <branch>` pour pousser la branche local sur le repo d'origin et la suivre
    * `git update-index --assume-unchanged config/config.php` pour ne prendre en compte les modifs de config

=== Revert les modifications de droits sur les fichiers ===

{{{
    git diff --summary | grep --color 'mode change 100755 => 100644' | cut -d' ' -f7- | xargs -d'\n' chmod +x
    git diff --summary | grep --color 'mode change 100644 => 100755' | cut -d' ' -f7- | xargs -d'\n' chmod -x
}}}

=== création d'un bare repo ===

    * `git clone --bare {URL/PATH} myrepo.git` 
    * `git fetch {URL/PATH} branch_local:branch_distante`
    
    Voir ce pastebin pour plus de détail sur le wrklow avec un bare git :
    https://pastebin.com/dSbpedLV

=== Clone avec fichiers sources séparés ===

    * `git init --separate-git-dir=. /home/myrepo`
    * `git remote add origin bitbucket.org:myrepo/myrepo.git`
    * `git checkout -b release --track origin/release`

=== Ne prendre que certain fichier/dossier lors du checkout ===
    * `git init && git remote add -f origin <url>`
    * `git config core.sparseCheckout true`
    * `echo "sys" > .git/info/sparse-chekcout`
    * `git pull origin master`

== Git pour le déploiement ==
	https://www.digitalocean.com/community/tutorials/how-to-set-up-automatic-deployment-with-git-with-a-vps
	
== Faire un merge ==

    * `:diffget 1` pour avoir la version de son local
    * `:diffupdate` pour mettre à jour la vue
    * `:only` pour garder que la partie mergé
    * Voir http://www.rosipov.com/blog/use-vimdiff-as-git-mergetool/

== Supprimer tous les fichiers non suivis ==
    
    * `git clean -f -n` pour voir les fichiers qui vont être supprimés
    * `git clean -f` pout supprimer les fichiers non suivis

== Tig et cherry pick ==

    * touche `b` pour voir toute les branches
    * sélectionner la branche depuis laquelle prendre le commit souhaité
    * selectioner le commit désiré puis appuyer sur `P`
    * le commit sera mis sur la branche

== Workflow avec git ==
    http://nvie.com/posts/a-successful-git-branching-model/
    https://jayenashar.wordpress.com/2012/11/18/yagbm-yet-another-git-branching-model/
    Outil indispensable : [[http://jonas.nitro.dk/tig/|tig]]
    
=== Workflow étape par étape ===
    
===== une feature =====

    `git checkout -b {feature} origin/master` => on crée la branche
    Faire son dev ET commiter
    `git merge --no-ff origin/master` => une fois le travail terminé et comité sur la branche, on merge sur le master 
    `git push origin {feature}:master :{feature}` => on pousse le merge sur le master (on omet le dernier param si branch non distante)

===== une release =====

    *Création de la release*
    `git checkout -b release-1.2 master`
    à cette étape on met le numéro de version à jours, on recompile, etc...
    voir http://teotti.com/a-successful-deploy-workflow-using-git-tags-and-a-changelog/ pour la maintenance d'un "CHANGELOG.md"
    `git commit -a -m "Version 1.2"` on commit la version

    *Déploiement de la release*
    `git tag -a 1.2.0` => une fois la release prete au deploiement
    `git checkout master` 
    `git merge --no-ff release-1.2`
    `git push origin master release-1.2`
    `git checkout release-1.2` => on se replace sur la dernière release
    `git branch -d master` => on efface le master

==== hotfixes ====

    `git checkout -b release-1.2`
    Fix the code and
    `git commit -m "Fixed severe production problem"`
    On change le numero de version
    `git commit -a -m "Version 1.2.1"`
    `git tag -a 1.2.1`
    `git checkout master`
    `git merge --no-ff release-1.2`


== Déploiement ==
    
    Voir : https://grimoire.ca/git/stop-using-git-pull-to-deploy 
    My deployment process, given a dedicated clone at $DEPLOY_TREE, is as follows:

    cd "${DEPLOY_TREE}"
    git fetch --all
    git checkout --force "${TARGET}" #${TARGET} peut être une branche ou un tag
    # Following two lines only required if you use submodules
    # git submodule sync
    # git submodule update --init --recursive
    # # Follow with actual deployment steps (run fabric/capistrano/make/etc)

== Git svn ==

   Exemple de fichier de conf :
   {{{
    [core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
    [svn-remote "svn"]
        url = https://srvnovo:8443/svn/adsnovo/projects/myawesomeproject
        fetch = recette:refs/remotes/origin/master
        fetch = prod:refs/remotes/origin/release
        ignore-paths = config/*|adbox/*
    [filter "git-crypt"]
        smudge = \"/usr/bin/git-crypt\" smudge
        clean = \"/usr/bin/git-crypt\" clean
        required = true
    [diff "git-crypt"]
        textconv = \"/usr/bin/git-crypt\" diff
    [remote "origin"]
        url = ssh://bitbucket.org/myawesomeproject/myawesomeproject.git
        fetch = +refs/heads/*:refs/remotes/origin/*
    [branch "master"]
        remote = origin
        merge = refs/heads/master
   }}}
   
   Si oublie d'un dossier dans le ignore-paths, alors obligé de faire un reset
   à la révision pour laquelle le dossier a été ajouté puis faire fetch.
   `git svn reset -r {REVISION}`
   `git svn fetch`
   `git rebase onto origin/master` # si sur git branch master existe
   
   Pour trouver le numéro de révision du premier commit d'un fichier :
   `svn log -r 1:HEAD --limit 1 <REPO_URL>` 

== TODO ==
    [ ] Maitriser les merges et les synchros
